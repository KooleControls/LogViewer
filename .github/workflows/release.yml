name: Build and Release Application Files

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.x"

      # Optional. Keep only if you actually call msbuild.exe directly (dotnet build/publish doesn't require this).
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Configure Azure DevOps NuGet feed (idempotent)
        shell: pwsh
        run: |
          $sourceName = "KooleControls"
          $sourceUrl  = "https://pkgs.dev.azure.com/koolecontrols/_packaging/koolecontrols/nuget/v3/index.json"

          # Remove if it already exists (avoid "already been added" failures)
          dotnet nuget remove source $sourceName 2>$null | Out-Null

          dotnet nuget add source $sourceUrl `
            --name $sourceName `
            --username "AzureDevOps" `
            --password "${{ secrets.AZURE_ARTIFACTS_PAT }}" `
            --store-password-in-clear-text

      - name: Derive version info from tag
        id: ver
        shell: pwsh
        run: |
          $tag = "${{ github.ref_name }}"  # v1.4.0-b1 or v1.4.0
          if (-not $tag.StartsWith("v")) {
            throw "Tag must start with 'v' (e.g., v1.4.0 or v1.4.0-b1). Got: $tag"
          }

          $version = $tag.Substring(1)     # 1.4.0-b1 or 1.4.0
          $isPrerelease = $version.Contains("-")

          # Base numeric version for Assembly/File versions
          $base = $version.Split("-")[0]   # 1.4.0
          if ($base -notmatch "^\d+\.\d+\.\d+$") {
            throw "Base version must be MAJOR.MINOR.PATCH (e.g., 1.4.0). Got: $base (from tag $tag)"
          }

          # AssemblyVersion/FileVersion must be numeric (4-part)
          $assembly = "$base.0"            # 1.4.0.0

          "tag=$tag"                 | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "version=$version"         | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "base=$base"               | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "assembly=$assembly"       | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "prerelease=$isPrerelease" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Guard stable tags must match latest prerelease commit (if prereleases exist)
        shell: pwsh
        run: |
          $tag = "${{ steps.ver.outputs.tag }}"
          $base = "${{ steps.ver.outputs.base }}"
          $isPrerelease = "${{ steps.ver.outputs.prerelease }}" -eq "True"

          if ($isPrerelease) {
            Write-Output "Prerelease tag ($tag): guard not applicable."
            exit 0
          }

          # Stable tag (e.g., v1.4.0).
          # If prerelease tags exist for the same base (v1.4.0-bN),
          # require the stable tag to point to the same commit as the highest bN.
          $pattern = "v$base-b*"
          $preTags = @(git tag -l $pattern)

          if ($preTags.Count -eq 0) {
            Write-Output "No prerelease tags found for $base. Stable release allowed."
            exit 0
          }

          $maxN = -1
          $maxTag = $null

          foreach ($t in $preTags) {
            if ($t -match "^v$([regex]::Escape($base))-b(\d+)$") {
              $n = [int]$Matches[1]
              if ($n -gt $maxN) {
                $maxN = $n
                $maxTag = $t
              }
            }
          }

          if (-not $maxTag) {
            Write-Output "Prerelease tags exist but none match v$base-bN exactly. Tags: $($preTags -join ', '). Stable release allowed."
            exit 0
          }

          $latestPreSha = (git rev-list -n 1 $maxTag).Trim()
          $stableSha = "${{ github.sha }}".Trim()

          Write-Output "Latest prerelease tag for $base is $maxTag at $latestPreSha"
          Write-Output "Stable tag $tag points to $stableSha"

          if ($latestPreSha -ne $stableSha) {
            throw "Guard failed: Stable tag $tag must point to the same commit as latest prerelease $maxTag. Tag the SAME commit, then push v$base."
          }

          Write-Output "Guard passed: stable tag matches latest prerelease commit."

      - name: Restore
        shell: pwsh
        run: dotnet restore "LogViewer/LogViewer.csproj"

      - name: Build
        shell: pwsh
        run: |
          dotnet build "LogViewer/LogViewer.csproj" -c Release --no-restore `
            /p:Version="${{ steps.ver.outputs.version }}" `
            /p:AssemblyVersion="${{ steps.ver.outputs.assembly }}" `
            /p:FileVersion="${{ steps.ver.outputs.assembly }}" `
            /p:InformationalVersion="${{ steps.ver.outputs.version }}"

      - name: Publish (Portable)
        shell: pwsh
        run: |
          dotnet publish "LogViewer/LogViewer.csproj" -c Release -o ./publish/portable --no-build `
            /p:Version="${{ steps.ver.outputs.version }}" `
            /p:AssemblyVersion="${{ steps.ver.outputs.assembly }}" `
            /p:FileVersion="${{ steps.ver.outputs.assembly }}" `
            /p:InformationalVersion="${{ steps.ver.outputs.version }}"

      - name: Create zip archive (Portable)
        id: zip
        shell: pwsh
        run: |
          $tag = "${{ steps.ver.outputs.tag }}"
          $zipName = "LogViewer_Portable_$tag.zip"
          Compress-Archive -Path ./publish/portable/* -DestinationPath ./$zipName -Force
          "zip=$zipName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Create GitHub Release + upload asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          prerelease: ${{ steps.ver.outputs.prerelease }}
          files: ${{ steps.zip.outputs.zip }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
